package com.smartcity.dao;

import com.smartcity.domain.Transaction;
import com.smartcity.exceptions.DbOperationException;
import com.smartcity.exceptions.NotFoundException;
import com.smartcity.mapper.TransactionMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public class TransactionDaoImpl implements TransactionDao {
    private static final Logger logger = LoggerFactory.getLogger(TransactionDaoImpl.class);
    private JdbcTemplate template;

    @Autowired
    public TransactionDaoImpl(DataSource source) {
        template = new JdbcTemplate(source);
    }

    public Transaction create(Transaction transaction) {
        try {
            LocalDateTime currDate = LocalDateTime.now();
            GeneratedKeyHolder holder = new GeneratedKeyHolder();
            transaction.setCreatedDate(currDate);
            transaction.setUpdatedDate(currDate);
            template.update(con -> createStatement(transaction, con), holder);
            transaction.setId(Optional.ofNullable(holder.getKey()).map(Number::longValue)
                    .orElseThrow(() -> new DbOperationException("Create transaction Dao method error: " +
                            "Autogenerated key is null")));
            return transaction;
        } catch (Exception e) {
            logger.error("Can't create transaction:{}. Error:{}", transaction, e.getMessage());
            throw new DbOperationException("Can't create transaction by id=" + transaction.getId() +
                    "Transaction:" + transaction);
        }
    }

    public Transaction findById(Long id) {
        try {
            return template.queryForObject(Queries.SQL_TRANSACTION_GET,
                    TransactionMapper.getInstance(), id);
        } catch (EmptyResultDataAccessException erd) {
            throw loggedNotFoundException(id);
        } catch (Exception e) {
            logger.error("Can't get transaction by id={}. Error: ", id, e);
            throw new DbOperationException("Can't get transaction with id." + id);
        }
    }

    public Transaction update(Transaction transaction) {
        int rowsAffected;
        try {
            LocalDateTime updatedDate = LocalDateTime.now();
            transaction.setUpdatedDate(updatedDate);
            rowsAffected = template.update(Queries.SQL_TRANSACTION_UPDATE,
                    transaction.getTaskId(),
                    transaction.getCurrentBudget(),
                    transaction.getTransactionBudget(),
                    updatedDate,
                    transaction.getId());
        } catch (Exception e) {
            logger.error("Update transaction error:" + transaction + " " + e.getMessage());
            throw new DbOperationException("Update transaction error");
        }
        if (rowsAffected < 1) {
            throw loggedNotFoundException(transaction.getId());
        }
        return transaction;
    }

    public boolean delete(Long id) {
        int rowsAffected;
        try {
            rowsAffected = template.update(Queries.SQL_TRANSACTION_DELETE, id);
        } catch (Exception e) {
            logger.error("Delete transaction by id = {} error: {}", id, e.getMessage());
            throw new DbOperationException("Delete transaction error");
        }
        if (rowsAffected < 1) {
            throw loggedNotFoundException(id);
        } else return true;
    }

    @Override
    public List<Transaction> findByTaskId(Long id) {
        List<Transaction> list;
        try {
            list = template.query(Queries.SQL_TRANSACTION_GET_BY_TASK_ID,
                    TransactionMapper.getInstance(), id);
        } catch (Exception e) {
            logger.error("Get transaction (task id = {}) exception. Message: {}",
                    id, e.getMessage());
            throw new DbOperationException("Get transaction exception");
        }
        return list;
    }

    private PreparedStatement createStatement(Transaction transaction, Connection con) throws SQLException {
        PreparedStatement ps = con.prepareStatement(
                Queries.SQL_TRANSACTION_CREATE, Statement.RETURN_GENERATED_KEYS);
        ps.setLong(1, transaction.getTaskId());
        ps.setLong(2, transaction.getCurrentBudget());
        ps.setLong(3, transaction.getTransactionBudget());
        ps.setObject(4, transaction.getCreatedDate());
        ps.setObject(5, transaction.getUpdatedDate());
        return ps;
    }

    private NotFoundException loggedNotFoundException(Long id) {
        NotFoundException notFoundException = new NotFoundException("Transaction not found.Id = " + id);
        logger.error("Runtime exception. Transaction by id = {} not found. Message: {}",
                id, notFoundException.getMessage());
        return notFoundException;
    }

    class Queries {
        static final String SQL_TRANSACTION_CREATE = "INSERT INTO Transactions(task_id,current_budget,transaction_budget," +
                "created_date,updated_date) values(?,?,?,?,?)";
        static final String SQL_TRANSACTION_GET = "SELECT * FROM Transactions where id = ?";
        static final String SQL_TRANSACTION_UPDATE = "UPDATE Transactions set task_id = ? , current_budget = ? ," +
                "transaction_budget = ? , updated_date = ? where id = ?";
        static final String SQL_TRANSACTION_DELETE = "DELETE FROM Transactions where id = ?";
        static final String SQL_TRANSACTION_GET_BY_TASK_ID = "SELECT * FROM Transactions where task_id = ?";
    }
}