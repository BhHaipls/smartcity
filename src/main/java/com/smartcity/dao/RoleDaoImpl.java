package com.smartcity.dao;

import com.smartcity.domain.Role;
import com.smartcity.exceptions.DbOperationException;
import com.smartcity.exceptions.NotFoundException;
import com.smartcity.mapper.RoleMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public class RoleDaoImpl implements RoleDao {

    private static final Logger logger = LoggerFactory.getLogger(RoleDaoImpl.class);
    private JdbcTemplate jdbcTemplate;
    private RoleMapper mapper;

    @Autowired
    public RoleDaoImpl(DataSource dataSource, RoleMapper mapper) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.mapper = mapper;
    }

    public Role create(Role role) {
        try {
            GeneratedKeyHolder holder = new GeneratedKeyHolder();
            LocalDateTime time = LocalDateTime.now();
            role.setCreatedDate(time);
            role.setUpdatedDate(time);
            jdbcTemplate.update(connection -> createStatement(role, connection), holder);
            role.setId(Optional.ofNullable(holder.getKey()).map(Number::longValue)
                    .orElseThrow(() -> new DbOperationException("Create Role Dao method error: AutoGeneratedKey = null")));
            return role;
        } catch (Exception e) {
            logger.error("Can't create role{}. Error {}", role, e.getMessage());
            throw new DbOperationException("Can't create role by id = " + role.getId() + " Role: " + role);
        }
    }

    public Role findById(Long id) {
        try {
            return jdbcTemplate.queryForObject(Queries.SQL_ROLE_GET_BY_ID, mapper, id);
        } catch (EmptyResultDataAccessException | NotFoundException e) {
            throw getAndLogRoleNotFoundException(id);
        } catch (Exception e) {
            logger.error("Can't get role with id={}. Error: ", id, e);
            throw new DbOperationException("Can't get role with id = " + id);
        }
    }

    public List<Role> getRolesByUserId(Long id) {
        try {
            return this.jdbcTemplate.query(Queries.SQL_GET_ROLES_BY_USER_ID, mapper, id);
        } catch (Exception e) {
            logger.error("Can't get Roles by User_id = {}. Error: ", id, e);
            throw new DbOperationException("Can't get roles by Users_id = id " + id);
        }
    }

    public List<Role> findAll() {
        try {
            return this.jdbcTemplate.query(Queries.SQL_ROLE_GET_ALL, mapper);
        } catch (Exception e) {
            logger.error("Can't get all Roles. Error: ", e.getMessage());
            throw new DbOperationException("Can't get all Roles");
        }
    }


    public Role update(Role role) {
        int rowsAffected;
        try {
            LocalDateTime updatedDate = LocalDateTime.now();
            role.setUpdatedDate(updatedDate);
            rowsAffected = jdbcTemplate.update(Queries.SQL_ROLE_UPDATE,
                    role.getName(),
                    updatedDate,
                    role.getId());
        } catch (Exception e) {
            logger.error("Update role error: " + role + " " + e.getMessage());
            throw new DbOperationException("Update role error");
        }
        if (rowsAffected < 1) {
            throw getAndLogRoleNotFoundException(role.getId());
        }
        return role;
    }


    @Override
    public boolean addRoleToUser(Long userId, Long roleId) {
        LocalDateTime time = LocalDateTime.now();
        try {
            jdbcTemplate.update(Queries.SQL_ADD_ROLE_TO_USER, userId, roleId, time, time);
            return true;
        } catch (Exception e) {
            logger.error("Can't insert values(userID, roleID): " + userId + " " + roleId + " into Users_roles." + e.getMessage());
            throw new DbOperationException("Insert Users_roles error");
        }
    }

    @Override
    public boolean removeRoleFromUser(Long userId, Long roleId) {
        try {
            int rowsAffected = jdbcTemplate.update(Queries.SQL_REMOVE_ROLE_FROM_USER, userId, roleId);
            return rowsAffected > 0;
        } catch (Exception e) {
            logger.error("Can't delete from Users_roles  with values(userID, roleID): " + userId + " " + roleId + " " + e.getMessage());
            throw new DbOperationException("Delete from Users_roles error");
        }

    }

    public boolean delete(Long id) {
        int rowsAffected;
        try {
            rowsAffected = jdbcTemplate.update(Queries.SQL_ROLE_DELETE, id);
        } catch (Exception e) {
            logger.error("Delete role error. " + e.getMessage());
            throw new DbOperationException("Delete Role exception");
        }
        if (rowsAffected < 1) {
            throw getAndLogRoleNotFoundException(id);
        } else return true;
    }

    private NotFoundException getAndLogRoleNotFoundException(Long id) {
        NotFoundException notFoundException = new NotFoundException("Role not found");
        logger.error("Runtime exception. Role not found id = {}. Message: {}", id, notFoundException.getMessage());
        return notFoundException;
    }

    private PreparedStatement createStatement(Role role, Connection connection) throws SQLException {
        PreparedStatement ps = connection.prepareStatement(Queries.SQL_ROLE_CREATE, Statement.RETURN_GENERATED_KEYS);
        ps.setString(1, role.getName());
        ps.setObject(2, role.getCreatedDate());
        ps.setObject(3, role.getUpdatedDate());
        return ps;
    }


    class Queries {

        static final String SQL_ROLE_DELETE = "delete from Roles where id = ?";

        static final String SQL_ROLE_CREATE = "insert into Roles (name,created_date,updated_date) values (?,?,?)";

        static final String SQL_ROLE_UPDATE = "update Roles set name = ?, updated_date = ? where id = ?";

        static final String SQL_ROLE_GET_BY_ID = "select * from Roles where id = ?";

        static final String SQL_ROLE_GET_ALL = "select * from Roles";

        static final String SQL_GET_ROLES_BY_USER_ID = "SELECT Roles.id, name, Roles.created_date, Roles.updated_date FROM Roles JOIN Users_roles ON Roles.id = Users_roles.role_id WHERE Users_roles.user_id = ?";

        static final String SQL_ADD_ROLE_TO_USER = "insert into Users_roles(user_id,role_id,created_date,updated_date) values (?,?,?,?)";

        static final String SQL_REMOVE_ROLE_FROM_USER = "delete from Users_roles where user_id = ? and role_id = ?";

    }
}
